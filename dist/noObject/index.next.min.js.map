{"version":3,"file":"index.next.min.js","sources":["../../src/converters/A1-Row.ts","../../src/converters/Col-A1.ts","../../src/converters/Row-A1.ts","../../src/validation/isValidA1.ts","../../src/validation/isValidNumber.ts","../../src/validation/A1Error.ts","../../src/index.noObject.ts","../../src/converters/A1-Col-1.ts","../../src/converters/A1-Col-2.ts"],"sourcesContent":["/**\n *\t@fileOverview Converts row string to number\n *\t@param {string} row\n *\n *\t@return {number}\n */\nexport default function(row: string): number\n{\n\treturn parseInt(row, 10);\n}","/**\n *\t@fileOverview Converts column number to letter\n *\t@author AdamL\n *\t@see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\n *\t@param {number} col\n *\n *\t@return {string}\n */\nexport default function(col: number): string\n{\n\tlet letter = '',\n\t\ttemp;\n\twhile(col > 0)\n\t{\n\t\ttemp \t= (col - 1) % 26;\n\t\tletter \t= String.fromCharCode(temp + 65) + letter;\n\t\tcol \t= (col - temp - 1) / 26;\n\t}\n\treturn letter;\n}","/**\n *\t@fileOverview Converts row number to string\n *\t@param {number} row\n *\n *\t@return {string}\n */\nexport default function(row: number): string\n{\n\treturn row.toString();\n}","/**\n *\t@fileOverview Checks validation\n *\t@param {string} a1\n *\n *\t@return {boolean}\n */\nexport default function(a1: string): boolean\n{\n\treturn /^[A-Z]+\\d+(:[A-Z]+\\d+)?$/i.test(a1);\n}","/**\n *\t@fileOverview Checks number validation\n *\t@param {T} n\n *\t@param {boolean} [strict = true]\n *\n *\t@return {boolean}\n */\nexport default function <T>(n: T, strict: boolean = true): boolean {\n  let isNumber = typeof n === \"number\" && n % 1 === 0;\n  return strict ? isNumber && +n > 0 : isNumber;\n}\n","/**\n *\t@fileOverview A1 notation errors\n */\nexport default class A1Error<T> extends Error\n{\n\tconstructor(a1: string)\n\tconstructor(col: number)\n\tconstructor(row: number)\n\tconstructor(unknown?: T)\n\tconstructor(something?: string | number | T)\n\t{\n\t\tlet str = JSON.stringify(something);\n\t\tsuper(str);\n\t\tthis.name \t\t= 'A1Error';\n\t\tthis.message \t= str;\n\t}\n\n\twasString(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 notation: ${this.message}`;\n\t\treturn this;\n\t}\n\n\twasNumber(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 number(s): ${this.message}`;\n\t\treturn this;\n\t}\n\n\twasUnknown(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 argument(s): ${this.message}`;\n\t\treturn this;\n\t}\n}","/**\n *\t@fileOverview Math operations and converting in A1 notation\n *\tSupports A1 notation like \"A1\" and \"A1:B2\"\n *\t@author FLighter\n */\n\nimport A1Col1 from \"./converters/A1-Col-1\"; // converter 1\nimport A1Col2 from \"./converters/A1-Col-2\"; // converter 2\nimport A1Row from \"./converters/A1-Row\";\nimport ColA1 from \"./converters/Col-A1\";\nimport RowA1 from \"./converters/Row-A1\";\nimport isValidA1 from \"./validation/isValidA1\";\nimport isValidNumber from \"./validation/isValidNumber\";\nimport A1Error from \"./validation/A1Error\";\n\nexport class A1 {\n  // Regular expression for parsing\n  private static _reg: RegExp = /^([A-Z]+)(\\d+)(?::([A-Z]+)(\\d+))?$/;\n  /**\n   *\tExample: A1:B2\n   */\n  private _colStart: number = 0; // A -> 1\n  private _rowStart: number = 0; // 1 -> 1\n  private _colEnd: number = 0; // B -> 2\n  private _rowEnd: number = 0; // 2 -> 2\n  private _converter: 1 | 2 = 1; // converter 1 | 2\n\n  /**\n   *\tParses A1 notation\n   *\t@param {string} a1\n   *\t@param {1 | 2}  converter\n   *\n   *\t@return {object} {cs: number, rs: number, ce: number, re: number}\n   */\n  private static _parse(\n    a1: string,\n    converter: 1 | 2\n  ): { cs: number; rs: number; ce: number; re: number } {\n    let [\n      ,\n      cs, // col start // A\n      rs, // row start // 1\n      ce, // col end \t// B\n      re // row end \t// 2\n    ] = a1.toUpperCase().match(this._reg);\n    ce = ce || cs;\n    re = re || rs;\n    let colStart = this._A1Col(cs, converter),\n      colEnd = this._A1Col(ce, converter),\n      rowStart = A1Row(rs),\n      rowEnd = A1Row(re);\n    // For non-standard A1\n    return {\n      cs: colEnd > colStart ? colStart : colEnd,\n      rs: rowEnd > rowStart ? rowStart : rowEnd,\n      ce: colEnd > colStart ? colEnd : colStart,\n      re: rowEnd > rowStart ? rowEnd : rowStart\n    };\n  }\n  /**\n   *\tConverts column letter to number using converter 1 or 2\n   *\t@param {string} a1\n   *\t@param {1 | 2} converter\n   *\n   *\t@return {number}\n   */\n  private static _A1Col(a1: string, converter: 1 | 2): number {\n    return converter === 1 ? A1Col1(a1) : A1Col2(a1);\n  }\n\n  /******************\n   *\tSTATIC METHODS\n   ******************/\n  /**\n   *\tChecks A1 notation\n   *\t@param {string} a1\n   *\n   *\t@return {boolean}\n   */\n  static isValid(a1: string): boolean {\n    return isValidA1(a1);\n  }\n  /**\n   *\tConverts the first column letter from A1 to number\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number}\n   */\n  static getCol(a1: string, converter: 1 | 2 = 1): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    return this._parse(a1, converter).cs;\n  }\n  /**\n   *\tConverts the last column letter from A1 to number\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number}\n   */\n  static getLastCol(a1: string, converter: 1 | 2 = 1): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    return this._parse(a1, converter).ce;\n  }\n  /**\n   *\tConverts number to column letter in A1\n   *\t@param {number} col\n   *\n   *\t@return {string}\n   */\n  static toCol(col: number): string {\n    if (!isValidNumber(col)) throw new A1Error(col).wasNumber();\n    return ColA1(col);\n  }\n  /**\n   *\tConverts the first row string to number\n   *\t@param {string} a1\n   *\n   *\t@return {number}\n   */\n  static getRow(a1: string): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    return this._parse(a1, 1).rs;\n  }\n  /**\n   *\tConverts the last row string to number\n   *\t@param {string} a1\n   *\n   *\t@return {number}\n   */\n  static getLastRow(a1: string): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    return this._parse(a1, 1).re;\n  }\n  /**\n   *\tConverts number to row string in A1\n   *\t@param {number} row\n   *\n   *\t@return {string}\n   */\n  static toRow(row: number): string {\n    if (!isValidNumber(row)) throw new A1Error(row).wasNumber();\n    return RowA1(row);\n  }\n  /**\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number} columns count\n   */\n  static getWidth(a1: string, converter: 1 | 2 = 1): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    let { ce, cs } = this._parse(a1, converter);\n    return ce - cs + 1;\n  }\n  /**\n   *\t@param {string} a1\n   *\n   *\t@return {number} rows count\n   */\n  static getHeight(a1: string): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    let { re, rs } = this._parse(a1, 1);\n    return re - rs + 1;\n  }\n\n  /***************\n   *\tCONSTRUCTOR\n   ***************/\n  /**\n   *\tIt handles cases:\n   *\tconstructor(col: number, row: number)\n   *\tconstructor(col: number, row: number, nRows: number)\n   *\tconstructor(col: number, row: number, nRows: number, nCols: number)\n   *\t@param {number[]} args\n   */\n  private _initNumber(...args: number[]): void {\n    let [col, row, nRows, nCols] = args;\n    nRows = nRows || 1;\n    nCols = nCols || 1;\n    let all = [col, row, nRows, nCols];\n    if (!all.every(n => isValidNumber(n)))\n      throw new A1Error(all.join(\", \")).wasNumber();\n    this._colStart = col; // the first col\n    this._rowStart = row; // the first row\n    this._colEnd = col + nCols - 1; // how many cols in total (cols length)\n    this._rowEnd = row + nRows - 1; // how many rows in total (rows length)\n  }\n  /**\n   *\tIt handles cases:\n   *\tconstructor(range: string)\n   *\tconstructor(rangeStart: string, rangeEnd: string)\n   *\t@param {string[]} args\n   */\n  private _initString(...args: string[]): void {\n    let [rangeStart, rangeEnd] = args,\n      range = rangeEnd\n        ? `${rangeStart}:${rangeEnd}` // rangeStart: string, rangeEnd: string\n        : rangeStart; // range: string\n    if (!isValidA1(range)) throw new A1Error(range).wasString();\n    let { cs, rs, ce, re } = A1._parse(range, this._converter);\n    this._colStart = cs;\n    this._rowStart = rs;\n    this._colEnd = ce;\n    this._rowEnd = re;\n  }\n  /**\n   *\tConstructor\n   */\n  constructor(range: string);\n  constructor(rangeStart: string, rangeEnd: string);\n  constructor(col: number, row: number);\n  constructor(col: number, row: number, nRows: number);\n  constructor(col: number, row: number, nRows: number, nCols: number);\n  constructor(\n    something: string | number,\n    something2?: string | number,\n    nRows?: number,\n    nCols?: number\n  ) {\n    // No arguments\n    if (!arguments.length) throw new A1Error().wasUnknown();\n    let type = typeof something;\n    // Number\n    if (type === \"number\") this._initNumber.apply(this, arguments);\n    // String\n    else if (type === \"string\") this._initString.apply(this, arguments);\n    // Unknown argument\n    else throw new A1Error(something).wasUnknown();\n  }\n\n  /***********\n   *\tMETHODS\n   ***********/\n  /**\n   *\t@return {string} in A1 notation\n   */\n  get(): string {\n    let start = ColA1(this._colStart) + RowA1(this._rowStart),\n      end = ColA1(this._colEnd) + RowA1(this._rowEnd);\n    return start === end ? start : `${start}:${end}`;\n  }\n  /**\n   *\t@return {string} in A1 notation\n   */\n  toString(): string {\n    return this.get();\n  }\n  /**\n   *\t@typedef {Object} Result\n   *\t@property {number} colStart\n   *\t@property {number} rowStart\n   *\t@property {number} colEnd\n   *\t@property {number} rowEnd\n   *\t@property {string} a1\n   *\t@property {number} rowsCount\n   *\t@property {number} colsCount\n   *\n   *\t@return {Result} full information about range\n   */\n  toJSON(): {\n    colStart: number;\n    rowStart: number;\n    colEnd: number;\n    rowEnd: number;\n    a1: string;\n    rowsCount: number;\n    colsCount: number;\n  } {\n    return {\n      colStart: this._colStart,\n      rowStart: this._rowStart,\n      colEnd: this._colEnd,\n      rowEnd: this._rowEnd,\n      a1: this.get(),\n      rowsCount: this._rowEnd - this._rowStart + 1,\n      colsCount: this._colEnd - this._colStart + 1\n    };\n  }\n  /**\n   *\t@return {number} start column\n   */\n  getCol(): number {\n    return this._colStart;\n  }\n  /**\n   *\t@return {number} end column\n   */\n  getLastCol(): number {\n    return this._colEnd;\n  }\n  /**\n   *\t@return {number} start row\n   */\n  getRow(): number {\n    return this._rowStart;\n  }\n  /**\n   *\t@return {number} end row\n   */\n  getLastRow(): number {\n    return this._rowEnd;\n  }\n  /**\n   *\t@return {number} columns count\n   */\n  getWidth(): number {\n    return this._colEnd - this._colStart + 1;\n  }\n  /**\n   *\t@return {number} rows count\n   */\n  getHeight(): number {\n    return this._rowEnd - this._rowStart + 1;\n  }\n  /**\n   *\t@return {A1} copy of this object\n   */\n  copy(): A1 {\n    return new A1(this.get());\n  }\n  /**\n   *\tAdds N cells to range along the x-axis\n   *\tif count >= 0 - adds to right\n   *\tif count <  0 - adds to left\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  addX(count: number): this {\n    if (!isValidNumber(count, false)) throw new A1Error(count).wasUnknown();\n    count >= 0 ? (this._colEnd += count) : (this._colStart += count);\n    this._colStart <= 0 && (this._colStart = 1);\n    return this;\n  }\n  /**\n   *\tAdds N cells to range along the y-axis\n   *\tif count >= 0 - adds to bottom\n   *\tif count <  0 - adds to top\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  addY(count: number): this {\n    if (!isValidNumber(count, false)) throw new A1Error(count).wasUnknown();\n    count >= 0 ? (this._rowEnd += count) : (this._rowStart += count);\n    this._rowStart <= 0 && (this._rowStart = 1);\n    return this;\n  }\n  /**\n   *\tAdds N cells to range along the x/y-axis\n   *\t@param {number} countX\n   *\t@param {number} countY\n   *\n   *\t@return {this}\n   */\n  add(countX: number, countY: number): this {\n    this.addX(countX);\n    this.addY(countY);\n    return this;\n  }\n  /**\n   *\tRemoves N cells from range along the x-axis\n   *\tif count >= 0 - removes from right\n   *\tif count <  0 - removes from left\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  removeX(count: number): this {\n    if (!isValidNumber(count, false)) throw new A1Error(count).wasUnknown();\n    if (count >= 0) {\n      this._colEnd -= count;\n      this._colEnd < this._colStart && (this._colEnd = this._colStart);\n    } else {\n      this._colStart -= count;\n      this._colStart > this._colEnd && (this._colStart = this._colEnd);\n    }\n    return this;\n  }\n  /**\n   *\tRemoves N cells from range along the y-axis\n   *\tif count >= 0 - removes from bottom\n   *\tif count <  0 - removes from top\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  removeY(count: number): this {\n    if (!isValidNumber(count, false)) throw new A1Error(count).wasUnknown();\n    if (count >= 0) {\n      this._rowEnd -= count;\n      this._rowEnd < this._rowStart && (this._rowEnd = this._rowStart);\n    } else {\n      this._rowStart -= count;\n      this._rowStart > this._rowEnd && (this._rowStart = this._rowEnd);\n    }\n    return this;\n  }\n  /**\n   *\tRemoves N cells from range along the x/y-axis\n   *\t@param {number} countX\n   *\t@param {number} countY\n   *\n   *\t@return {this}\n   */\n  remove(countX: number, countY: number): this {\n    this.removeX(countX);\n    this.removeY(countY);\n    return this;\n  }\n  /**\n   *\tShifts the range along the x-axis\n   *\tIf offset >= 0 - shifts to right\n   *\tIf offset <  0 - shifts to left\n   *\t@param {number} offset\n   *\n   *\t@return {this}\n   */\n  shiftX(offset: number): this {\n    if (!isValidNumber(offset, false)) throw new A1Error(offset).wasUnknown();\n    let diff = this._colEnd - this._colStart,\n      start = this._colStart + offset,\n      end = this._colEnd + offset;\n    this._colStart = start > 0 ? start : 1;\n    this._colEnd = start > 0 ? end : diff + 1;\n    return this;\n  }\n  /**\n   *\tShifts the range along the y-axis\n   *\tIf offset >= 0 - shifts to bottom\n   *\tIf offset <  0 - shifts to top\n   *\t@param {number} offset\n   *\n   *\t@return {this}\n   */\n  shiftY(offset: number): this {\n    if (!isValidNumber(offset, false)) throw new A1Error(offset).wasUnknown();\n    let diff = this._rowEnd - this._rowStart,\n      start = this._rowStart + offset,\n      end = this._rowEnd + offset;\n    this._rowStart = start > 0 ? start : 1;\n    this._rowEnd = start > 0 ? end : diff + 1;\n    return this;\n  }\n  /**\n   *\tShifts the range along the x/y-axis\n   *\t@param {number} offsetX\n   *\t@param {number} offsetY\n   *\n   *\t@return {this}\n   */\n  shift(offsetX: number, offsetY: number): this {\n    this.shiftX(offsetX);\n    this.shiftY(offsetY);\n    return this;\n  }\n}\n","/**\n *\t@fileOverview Converts column letter to number\n *\t@author AdamL\n *\t@see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\n *\t@param {string} col\n *\n *\t@return {number}\n */\nexport default function(col: string): number\n{\n\tlet column = 0,\n\t\tlength = col.length;\n\tfor(let i = 0; i < length; i++)\n\t\tcolumn += (col.charCodeAt(i) - 64) * Math.pow(26, length - i - 1);\n\treturn column;\n}","/**\n *\t@fileOverview Converts column letter to number\n *\t@author Flambino\n *\t@see https://codereview.stackexchange.com/questions/90112/a1notation-conversion-to-row-column-index\n *\t@param {string} col\n *\n *\t@return {number}\n */\nexport default function(col: string): number\n{\n\tlet i,\n\t\tl,\n\t\tchr,\n\t\tsum \t= 0,\n\t\tA \t\t= 'A'.charCodeAt(0),\n\t\tradix \t= 'Z'.charCodeAt(0) - A + 1;\n\tfor(i = 0, l = col.length; i < l; i++)\n\t{\n\t\tchr = col.charCodeAt(i);\n\t\tsum = sum * radix + chr - A + 1;\n\t}\n\treturn sum;\n}"],"names":["row","parseInt","col","temp","letter","String","fromCharCode","toString","a1","test","n","strict","isNumber","A1Error","Error","[object Object]","something","str","JSON","stringify","super","this","name","message","A1","something2","nRows","nCols","arguments","length","wasUnknown","type","_initNumber","apply","_initString","converter","cs","rs","ce","re","toUpperCase","match","_reg","colStart","_A1Col","colEnd","rowStart","A1Row","rowEnd","column","i","charCodeAt","Math","pow","A1Col1","l","chr","sum","A","radix","A1Col2","isValidA1","wasString","_parse","isValidNumber","wasNumber","ColA1","RowA1","args","all","every","join","_colStart","_rowStart","_colEnd","_rowEnd","rangeStart","rangeEnd","range","_converter","start","end","get","rowsCount","colsCount","count","countX","countY","addX","addY","removeX","removeY","offset","diff","offsetX","offsetY","shiftX","shiftY"],"mappings":"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"}
{"version":3,"file":"index.next.min.js","sources":["../../src/converters/A1-Row.ts","../../src/converters/Col-A1.ts","../../src/converters/Row-A1.ts","../../src/validation/isValidA1.ts","../../src/validation/isValidNumber.ts","../../src/validation/A1Error.ts","../../src/index.ts","../../src/converters/A1-Col-1.ts","../../src/converters/A1-Col-2.ts"],"sourcesContent":["/**\n *\t@fileOverview Converts row string to number\n *\t@param {string} row\n *\n *\t@return {number}\n */\nexport default function(row: string): number\n{\n\treturn parseInt(row, 10);\n}","/**\n *\t@fileOverview Converts column number to letter\n *\t@author AdamL\n *\t@see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\n *\t@param {number} col\n *\n *\t@return {string}\n */\nexport default function(col: number): string\n{\n\tlet letter = '',\n\t\ttemp;\n\twhile(col > 0)\n\t{\n\t\ttemp \t= (col - 1) % 26;\n\t\tletter \t= String.fromCharCode(temp + 65) + letter;\n\t\tcol \t= (col - temp - 1) / 26;\n\t}\n\treturn letter;\n}","/**\n *\t@fileOverview Converts row number to string\n *\t@param {number} row\n *\n *\t@return {string}\n */\nexport default function(row: number): string\n{\n\treturn row.toString();\n}","/**\n *\t@fileOverview Checks validation\n *\t@param {string} a1\n *\n *\t@return {boolean}\n */\nexport default function(a1: string): boolean\n{\n\treturn /^[A-Z]+\\d+(:[A-Z]+\\d+)?$/i.test(a1);\n}","/**\n *\t@fileOverview Checks number validation\n *\t@param {T} n\n *\t@param {boolean} [strict = true]\n *\n *\t@return {boolean}\n */\nexport default function <T>(n: T, strict: boolean = true): boolean {\n  let isNumber = typeof n === \"number\" && n % 1 === 0;\n  return strict ? isNumber && +n > 0 : isNumber;\n}\n","/**\n *\t@fileOverview A1 notation errors\n */\nexport default class A1Error<T> extends Error\n{\n\tconstructor(a1: string)\n\tconstructor(col: number)\n\tconstructor(row: number)\n\tconstructor(unknown?: T)\n\tconstructor(something?: string | number | T)\n\t{\n\t\tlet str = JSON.stringify(something);\n\t\tsuper(str);\n\t\tthis.name \t\t= 'A1Error';\n\t\tthis.message \t= str;\n\t}\n\n\twasString(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 notation: ${this.message}`;\n\t\treturn this;\n\t}\n\n\twasNumber(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 number(s): ${this.message}`;\n\t\treturn this;\n\t}\n\n\twasUnknown(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 argument(s): ${this.message}`;\n\t\treturn this;\n\t}\n}","/**\n *\t@fileOverview Math operations and converting in A1 notation\n *\tSupports A1 notation like \"A1\" and \"A1:B2\"\n *\t@author FLighter\n */\n\nimport A1Col1 from \"./converters/A1-Col-1\"; // converter 1\nimport A1Col2 from \"./converters/A1-Col-2\"; // converter 2\nimport A1Row from \"./converters/A1-Row\";\nimport ColA1 from \"./converters/Col-A1\";\nimport RowA1 from \"./converters/Row-A1\";\nimport isValidA1 from \"./validation/isValidA1\";\nimport isValidNumber from \"./validation/isValidNumber\";\nimport A1Error from \"./validation/A1Error\";\nimport options from \"./options/options\";\nimport advancedOptions from \"./options/advancedOptions\";\n\nexport class A1 {\n  // Regular expression for parsing\n  private static _reg: RegExp = /^([A-Z]+)(\\d+)(?::([A-Z]+)(\\d+))?$/;\n  /**\n   *\tExample: A1:B2\n   */\n  private _colStart: number = 0; // A -> 1\n  private _rowStart: number = 0; // 1 -> 1\n  private _colEnd: number = 0; // B -> 2\n  private _rowEnd: number = 0; // 2 -> 2\n  private _converter: 1 | 2 = 1; // converter 1 | 2\n\n  /**\n   *\tParses A1 notation\n   *\t@param {string} a1\n   *\t@param {1 | 2}  converter\n   *\n   *\t@return {object} {cs: number, rs: number, ce: number, re: number}\n   */\n  private static _parse(\n    a1: string,\n    converter: 1 | 2\n  ): { cs: number; rs: number; ce: number; re: number } {\n    let [\n      ,\n      cs, // col start // A\n      rs, // row start // 1\n      ce, // col end \t// B\n      re // row end \t// 2\n    ] = a1.toUpperCase().match(this._reg);\n    ce = ce || cs;\n    re = re || rs;\n    let colStart = this._A1Col(cs, converter),\n      colEnd = this._A1Col(ce, converter),\n      rowStart = A1Row(rs),\n      rowEnd = A1Row(re);\n    // For non-standard A1\n    return {\n      cs: colEnd > colStart ? colStart : colEnd,\n      rs: rowEnd > rowStart ? rowStart : rowEnd,\n      ce: colEnd > colStart ? colEnd : colStart,\n      re: rowEnd > rowStart ? rowEnd : rowStart\n    };\n  }\n  /**\n   *\tConverts column letter to number using converter 1 or 2\n   *\t@param {string} a1\n   *\t@param {1 | 2} converter\n   *\n   *\t@return {number}\n   */\n  private static _A1Col(a1: string, converter: 1 | 2): number {\n    return converter === 1 ? A1Col1(a1) : A1Col2(a1);\n  }\n\n  /******************\n   *\tSTATIC METHODS\n   ******************/\n  /**\n   *\tChecks A1 notation\n   *\t@param {string} a1\n   *\n   *\t@return {boolean}\n   */\n  static isValid(a1: string): boolean {\n    return isValidA1(a1);\n  }\n  /**\n   *\tConverts the first column letter from A1 to number\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number}\n   */\n  static getCol(a1: string, converter: 1 | 2 = 1): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    return this._parse(a1, converter).cs;\n  }\n  /**\n   *\tConverts the last column letter from A1 to number\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number}\n   */\n  static getLastCol(a1: string, converter: 1 | 2 = 1): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    return this._parse(a1, converter).ce;\n  }\n  /**\n   *\tConverts number to column letter in A1\n   *\t@param {number} col\n   *\n   *\t@return {string}\n   */\n  static toCol(col: number): string {\n    if (!isValidNumber(col)) throw new A1Error(col).wasNumber();\n    return ColA1(col);\n  }\n  /**\n   *\tConverts the first row string to number\n   *\t@param {string} a1\n   *\n   *\t@return {number}\n   */\n  static getRow(a1: string): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    return this._parse(a1, 1).rs;\n  }\n  /**\n   *\tConverts the last row string to number\n   *\t@param {string} a1\n   *\n   *\t@return {number}\n   */\n  static getLastRow(a1: string): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    return this._parse(a1, 1).re;\n  }\n  /**\n   *\tConverts number to row string in A1\n   *\t@param {number} row\n   *\n   *\t@return {string}\n   */\n  static toRow(row: number): string {\n    if (!isValidNumber(row)) throw new A1Error(row).wasNumber();\n    return RowA1(row);\n  }\n  /**\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number} columns count\n   */\n  static getWidth(a1: string, converter: 1 | 2 = 1): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    let { ce, cs } = this._parse(a1, converter);\n    return ce - cs + 1;\n  }\n  /**\n   *\t@param {string} a1\n   *\n   *\t@return {number} rows count\n   */\n  static getHeight(a1: string): number {\n    if (!isValidA1(a1)) throw new A1Error(a1).wasString();\n    let { re, rs } = this._parse(a1, 1);\n    return re - rs + 1;\n  }\n\n  /***************\n   *\tCONSTRUCTOR\n   ***************/\n  /**\n   *\tIt handles case:\n   *\tconstructor(object: options)\n   *\t@param {options[]} args\n   */\n  private _initObject(...args: options[]): void {\n    const isString = <T>(some: T) => typeof some === \"string\",\n      areEmpty = (all: advancedOptions, excludingKeys: string | string[]) => {\n        !Array.isArray(excludingKeys) && (excludingKeys = [excludingKeys]);\n        for (let key in all)\n          if (excludingKeys.indexOf(key) === -1 && all[key].val) return false;\n        return true;\n      };\n    let options = args[0],\n      { converter } = options;\n    if (converter && [1, 2].indexOf(converter) === -1)\n      throw new A1Error({ converter }).wasUnknown();\n    this._converter = converter || 1;\n    // Create object with types\n    let all: advancedOptions = {};\n    [\n      \"colStart\",\n      \"rowStart\",\n      \"colEnd\",\n      \"rowEnd\",\n      \"a1Start\",\n      \"a1End\",\n      \"nCols\",\n      \"nRows\"\n    ].forEach(key => {\n      let val = options[key];\n      all[key] = {\n        isString: isString(val),\n        isNumber: isValidNumber(val),\n        val\n      };\n    });\n    let {\n      colStart,\n      rowStart,\n      colEnd,\n      rowEnd,\n      a1Start,\n      a1End,\n      nCols,\n      nRows\n    } = all;\n    /**\n     *\tExecuting by priority\n     */\n    switch (true) {\n      /**\n       *\ta1Start\n       */\n      case a1Start.isString && areEmpty(all, \"a1Start\"):\n        return this._initString(a1Start.val as string);\n      /**\n       *\ta1Start, a1End\n       */\n      case a1Start.isString &&\n        a1End.isString &&\n        areEmpty(all, [\"a1Start\", \"a1End\"]):\n        return this._initString(a1Start.val as string, a1End.val as string);\n      /**\n       *\tcolStart, rowStart (string, string)\n       */\n      case colStart.isString &&\n        rowStart.isString &&\n        areEmpty(all, [\"colStart\", \"rowStart\"]):\n        return this._initString(colStart.val + (rowStart.val as string));\n      /**\n       *\tcolStart, rowStart (number, number)\n       */\n      case colStart.isNumber &&\n        rowStart.isNumber &&\n        areEmpty(all, [\"colStart\", \"rowStart\"]):\n        return this._initNumber(colStart.val as number, rowStart.val as number);\n      /**\n       *\tcolStart, rowStart, nRows (number, number, number)\n       */\n      case colStart.isNumber &&\n        rowStart.isNumber &&\n        nRows.isNumber &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"nRows\"]):\n        return this._initNumber(\n          colStart.val as number,\n          rowStart.val as number,\n          nRows.val as number\n        );\n      /**\n       *\tcolStart, rowStart, nCols (number, number, number)\n       */\n      case colStart.isNumber &&\n        rowStart.isNumber &&\n        nCols.isNumber &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"nCols\"]):\n        return this._initNumber(\n          colStart.val as number,\n          rowStart.val as number,\n          1,\n          nCols.val as number\n        );\n      /**\n       *\tcolStart, rowStart, nRows, nCols (number, number, number, number)\n       */\n      case colStart.isNumber &&\n        rowStart.isNumber &&\n        nRows.isNumber &&\n        nCols.isNumber &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"nRows\", \"nCols\"]):\n        return this._initNumber(\n          colStart.val as number,\n          rowStart.val as number,\n          nRows.val as number,\n          nCols.val as number\n        );\n      /**\n       *\tcolStart, rowStart, colEnd (string, string, string)\n       */\n      case colStart.isString &&\n        rowStart.isString &&\n        colEnd.isString &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"colEnd\"]):\n        return this._initString(\n          `${colStart.val}${rowStart.val}:${colEnd.val}${rowStart.val}`\n        );\n      /**\n       *\tcolStart, rowStart, colEnd (number, number, number)\n       */\n      case colStart.isNumber &&\n        rowStart.isNumber &&\n        colEnd.isNumber &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"colEnd\"]):\n        return this._initNumber(\n          colStart.val as number,\n          rowStart.val as number,\n          1,\n          (colEnd.val as number) - (colStart.val as number) + 1\n        );\n      /**\n       *\tcolStart, rowStart, rowEnd (string, string, string)\n       */\n      case colStart.isString &&\n        rowStart.isString &&\n        rowEnd.isString &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"rowEnd\"]):\n        return this._initString(\n          `${colStart.val}${rowStart.val}:${colStart.val}${rowEnd.val}`\n        );\n      /**\n       *\tcolStart, rowStart, rowEnd (number, number, number)\n       */\n      case colStart.isNumber &&\n        rowStart.isNumber &&\n        rowEnd.isNumber &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"rowEnd\"]):\n        return this._initNumber(\n          colStart.val as number,\n          rowStart.val as number,\n          (rowEnd.val as number) - (rowStart.val as number) + 1\n        );\n      /**\n       *\tcolStart, rowStart, colEnd, rowEnd (string, string, string, string)\n       */\n      case colStart.isString &&\n        rowStart.isString &&\n        colEnd.isString &&\n        rowEnd.isString &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"colEnd\", \"rowEnd\"]):\n        return this._initString(\n          `${colStart.val}${rowStart.val}:${colEnd.val}${rowEnd.val}`\n        );\n      /**\n       *\tcolStart, rowStart, colEnd, rowEnd (number, number, number, number)\n       */\n      case colStart.isNumber &&\n        rowStart.isNumber &&\n        colEnd.isNumber &&\n        rowEnd.isNumber &&\n        areEmpty(all, [\"colStart\", \"rowStart\", \"colEnd\", \"rowEnd\"]):\n        return this._initNumber(\n          colStart.val as number,\n          rowStart.val as number,\n          (rowEnd.val as number) - (rowStart.val as number) + 1,\n          (colEnd.val as number) - (colStart.val as number) + 1\n        );\n      /**\n       *\tInvalid arguments combination\n       */\n      default:\n        throw new A1Error(options).wasUnknown();\n    }\n  }\n  /**\n   *\tIt handles cases:\n   *\tconstructor(col: number, row: number)\n   *\tconstructor(col: number, row: number, nRows: number)\n   *\tconstructor(col: number, row: number, nRows: number, nCols: number)\n   *\t@param {number[]} args\n   */\n  private _initNumber(...args: number[]): void {\n    let [col, row, nRows, nCols] = args;\n    nRows = nRows || 1;\n    nCols = nCols || 1;\n    let all = [col, row, nRows, nCols];\n    if (!all.every(n => isValidNumber(n)))\n      throw new A1Error(all.join(\", \")).wasNumber();\n    this._colStart = col; // the first col\n    this._rowStart = row; // the first row\n    this._colEnd = col + nCols - 1; // how many cols in total (cols length)\n    this._rowEnd = row + nRows - 1; // how many rows in total (rows length)\n  }\n  /**\n   *\tIt handles cases:\n   *\tconstructor(range: string)\n   *\tconstructor(rangeStart: string, rangeEnd: string)\n   *\t@param {string[]} args\n   */\n  private _initString(...args: string[]): void {\n    let [rangeStart, rangeEnd] = args,\n      range = rangeEnd\n        ? `${rangeStart}:${rangeEnd}` // rangeStart: string, rangeEnd: string\n        : rangeStart; // range: string\n    if (!isValidA1(range)) throw new A1Error(range).wasString();\n    let { cs, rs, ce, re } = A1._parse(range, this._converter);\n    this._colStart = cs;\n    this._rowStart = rs;\n    this._colEnd = ce;\n    this._rowEnd = re;\n  }\n  /**\n   *\tConstructor\n   */\n  constructor(object: options);\n  constructor(range: string);\n  constructor(rangeStart: string, rangeEnd: string);\n  constructor(col: number, row: number);\n  constructor(col: number, row: number, nRows: number);\n  constructor(col: number, row: number, nRows: number, nCols: number);\n  constructor(\n    something: string | number | options,\n    something2?: string | number,\n    nRows?: number,\n    nCols?: number\n  ) {\n    // No arguments\n    if (!arguments.length) throw new A1Error().wasUnknown();\n    let type = typeof something;\n    // Object\n    if (something && type === \"object\") this._initObject.apply(this, arguments);\n    // Number\n    else if (type === \"number\") this._initNumber.apply(this, arguments);\n    // String\n    else if (type === \"string\") this._initString.apply(this, arguments);\n    // Unknown argument\n    else throw new A1Error(something).wasUnknown();\n  }\n\n  /***********\n   *\tMETHODS\n   ***********/\n  /**\n   *\t@return {string} in A1 notation\n   */\n  get(): string {\n    let start = ColA1(this._colStart) + RowA1(this._rowStart),\n      end = ColA1(this._colEnd) + RowA1(this._rowEnd);\n    return start === end ? start : `${start}:${end}`;\n  }\n  /**\n   *\t@return {string} in A1 notation\n   */\n  toString(): string {\n    return this.get();\n  }\n  /**\n   *\t@typedef {Object} Result\n   *\t@property {number} colStart\n   *\t@property {number} rowStart\n   *\t@property {number} colEnd\n   *\t@property {number} rowEnd\n   *\t@property {string} a1\n   *\t@property {number} rowsCount\n   *\t@property {number} colsCount\n   *\n   *\t@return {Result} full information about range\n   */\n  toJSON(): {\n    colStart: number;\n    rowStart: number;\n    colEnd: number;\n    rowEnd: number;\n    a1: string;\n    rowsCount: number;\n    colsCount: number;\n  } {\n    return {\n      colStart: this._colStart,\n      rowStart: this._rowStart,\n      colEnd: this._colEnd,\n      rowEnd: this._rowEnd,\n      a1: this.get(),\n      rowsCount: this._rowEnd - this._rowStart + 1,\n      colsCount: this._colEnd - this._colStart + 1\n    };\n  }\n  /**\n   *\t@return {number} start column\n   */\n  getCol(): number {\n    return this._colStart;\n  }\n  /**\n   *\t@return {number} end column\n   */\n  getLastCol(): number {\n    return this._colEnd;\n  }\n  /**\n   *\t@return {number} start row\n   */\n  getRow(): number {\n    return this._rowStart;\n  }\n  /**\n   *\t@return {number} end row\n   */\n  getLastRow(): number {\n    return this._rowEnd;\n  }\n  /**\n   *\t@return {number} columns count\n   */\n  getWidth(): number {\n    return this._colEnd - this._colStart + 1;\n  }\n  /**\n   *\t@return {number} rows count\n   */\n  getHeight(): number {\n    return this._rowEnd - this._rowStart + 1;\n  }\n  /**\n   *\t@return {A1} copy of this object\n   */\n  copy(): A1 {\n    return new A1(this.get());\n  }\n  /**\n   *\tAdds N cells to range along the x-axis\n   *\tif count >= 0 - adds to right\n   *\tif count <  0 - adds to left\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  addX(count: number): this {\n    if (!isValidNumber(count, false)) throw new A1Error(count).wasUnknown();\n    count >= 0 ? (this._colEnd += count) : (this._colStart += count);\n    this._colStart <= 0 && (this._colStart = 1);\n    return this;\n  }\n  /**\n   *\tAdds N cells to range along the y-axis\n   *\tif count >= 0 - adds to bottom\n   *\tif count <  0 - adds to top\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  addY(count: number): this {\n    if (!isValidNumber(count, false)) throw new A1Error(count).wasUnknown();\n    count >= 0 ? (this._rowEnd += count) : (this._rowStart += count);\n    this._rowStart <= 0 && (this._rowStart = 1);\n    return this;\n  }\n  /**\n   *\tAdds N cells to range along the x/y-axis\n   *\t@param {number} countX\n   *\t@param {number} countY\n   *\n   *\t@return {this}\n   */\n  add(countX: number, countY: number): this {\n    this.addX(countX);\n    this.addY(countY);\n    return this;\n  }\n  /**\n   *\tRemoves N cells from range along the x-axis\n   *\tif count >= 0 - removes from right\n   *\tif count <  0 - removes from left\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  removeX(count: number): this {\n    if (!isValidNumber(count, false)) throw new A1Error(count).wasUnknown();\n    if (count >= 0) {\n      this._colEnd -= count;\n      this._colEnd < this._colStart && (this._colEnd = this._colStart);\n    } else {\n      this._colStart -= count;\n      this._colStart > this._colEnd && (this._colStart = this._colEnd);\n    }\n    return this;\n  }\n  /**\n   *\tRemoves N cells from range along the y-axis\n   *\tif count >= 0 - removes from bottom\n   *\tif count <  0 - removes from top\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  removeY(count: number): this {\n    if (!isValidNumber(count, false)) throw new A1Error(count).wasUnknown();\n    if (count >= 0) {\n      this._rowEnd -= count;\n      this._rowEnd < this._rowStart && (this._rowEnd = this._rowStart);\n    } else {\n      this._rowStart -= count;\n      this._rowStart > this._rowEnd && (this._rowStart = this._rowEnd);\n    }\n    return this;\n  }\n  /**\n   *\tRemoves N cells from range along the x/y-axis\n   *\t@param {number} countX\n   *\t@param {number} countY\n   *\n   *\t@return {this}\n   */\n  remove(countX: number, countY: number): this {\n    this.removeX(countX);\n    this.removeY(countY);\n    return this;\n  }\n  /**\n   *\tShifts the range along the x-axis\n   *\tIf offset >= 0 - shifts to right\n   *\tIf offset <  0 - shifts to left\n   *\t@param {number} offset\n   *\n   *\t@return {this}\n   */\n  shiftX(offset: number): this {\n    if (!isValidNumber(offset, false)) throw new A1Error(offset).wasUnknown();\n    let diff = this._colEnd - this._colStart,\n      start = this._colStart + offset,\n      end = this._colEnd + offset;\n    this._colStart = start > 0 ? start : 1;\n    this._colEnd = start > 0 ? end : diff + 1;\n    return this;\n  }\n  /**\n   *\tShifts the range along the y-axis\n   *\tIf offset >= 0 - shifts to bottom\n   *\tIf offset <  0 - shifts to top\n   *\t@param {number} offset\n   *\n   *\t@return {this}\n   */\n  shiftY(offset: number): this {\n    if (!isValidNumber(offset, false)) throw new A1Error(offset).wasUnknown();\n    let diff = this._rowEnd - this._rowStart,\n      start = this._rowStart + offset,\n      end = this._rowEnd + offset;\n    this._rowStart = start > 0 ? start : 1;\n    this._rowEnd = start > 0 ? end : diff + 1;\n    return this;\n  }\n  /**\n   *\tShifts the range along the x/y-axis\n   *\t@param {number} offsetX\n   *\t@param {number} offsetY\n   *\n   *\t@return {this}\n   */\n  shift(offsetX: number, offsetY: number): this {\n    this.shiftX(offsetX);\n    this.shiftY(offsetY);\n    return this;\n  }\n}\n","/**\n *\t@fileOverview Converts column letter to number\n *\t@author AdamL\n *\t@see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\n *\t@param {string} col\n *\n *\t@return {number}\n */\nexport default function(col: string): number\n{\n\tlet column = 0,\n\t\tlength = col.length;\n\tfor(let i = 0; i < length; i++)\n\t\tcolumn += (col.charCodeAt(i) - 64) * Math.pow(26, length - i - 1);\n\treturn column;\n}","/**\n *\t@fileOverview Converts column letter to number\n *\t@author Flambino\n *\t@see https://codereview.stackexchange.com/questions/90112/a1notation-conversion-to-row-column-index\n *\t@param {string} col\n *\n *\t@return {number}\n */\nexport default function(col: string): number\n{\n\tlet i,\n\t\tl,\n\t\tchr,\n\t\tsum \t= 0,\n\t\tA \t\t= 'A'.charCodeAt(0),\n\t\tradix \t= 'Z'.charCodeAt(0) - A + 1;\n\tfor(i = 0, l = col.length; i < l; i++)\n\t{\n\t\tchr = col.charCodeAt(i);\n\t\tsum = sum * radix + chr - A + 1;\n\t}\n\treturn sum;\n}"],"names":["row","parseInt","col","temp","letter","String","fromCharCode","toString","a1","test","n","strict","isNumber","A1Error","Error","[object Object]","something","str","JSON","stringify","super","this","name","message","A1","something2","nRows","nCols","arguments","length","wasUnknown","type","_initObject","apply","_initNumber","_initString","converter","cs","rs","ce","re","toUpperCase","match","_reg","colStart","_A1Col","colEnd","rowStart","A1Row","rowEnd","column","i","charCodeAt","Math","pow","A1Col1","l","chr","sum","A","radix","A1Col2","isValidA1","wasString","_parse","isValidNumber","wasNumber","ColA1","RowA1","args","areEmpty","all","excludingKeys","Array","isArray","key","indexOf","val","options","_converter","forEach","some","isString","a1Start","a1End","every","join","_colStart","_rowStart","_colEnd","_rowEnd","rangeStart","rangeEnd","range","start","end","get","rowsCount","colsCount","count","countX","countY","addX","addY","removeX","removeY","offset","diff","offsetX","offsetY","shiftX","shiftY"],"mappings":"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"}